<!DOCTYPE html><html><head><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><link href=/bundle.css rel=stylesheet><script src=/bundle.js defer></script><script src=/check.js async></script><link href=/favicon.ico rel="shortcut icon"><link href=/favicon.svg rel=icon><title>挂起极域电子教室客户端 - kkocdko's blog</title><meta content="也许我们可以温和一点儿" name=description><meta content=rgb(63,81,181) name=theme-color></head><body><main><article class=card><h1 id=挂起极域电子教室客户端>挂起极域电子教室客户端</h1><h3 id=code>Code</h3><pre><code class=language-c>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;tlhelp32.h&gt;

// ==============================

void printLogHead();
void minimizeForegroundWindow();
int getPid(char*);

// ==============================

int main()
{
    typedef long (NTAPI *_NtSuspendProcess)(IN HANDLE handle);
    _NtSuspendProcess NtSuspendProcess = (_NtSuspendProcess)GetProcAddress(GetModuleHandle(&quot;ntdll&quot;), &quot;NtSuspendProcess&quot;);
    typedef long (NTAPI *_NtResumeProcess)(IN HANDLE handle);
    _NtResumeProcess NtResumeProcess = (_NtResumeProcess)GetProcAddress(GetModuleHandle(&quot;ntdll&quot;), &quot;NtResumeProcess&quot;);
    typedef long (NTAPI *_NtTerminateProcess)(IN HANDLE handle);
    _NtTerminateProcess NtTerminateProcess = (_NtTerminateProcess)GetProcAddress(GetModuleHandle(&quot;ntdll&quot;), &quot;NtTerminateProcess&quot;);

    int pid = getPid((char*)&quot;notepad.exe&quot;); // StudentMain.exe
    if (pid)
    {
        printLogHead();
        printf(&quot;Suspend: Win + Alt + S\n&quot;);
        printLogHead();
        printf(&quot;Resume: Win + Alt + R\n&quot;);
        printLogHead();
        printf(&quot;Kill: Win + Alt + K\n&quot;);
    }
    else
    {
        printLogHead();
        printf(&quot;Process not found\n&quot;);
        printLogHead();
        printf(&quot;Press any key to exit\n&quot;);
        getchar();
        return 1;
    }
    HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    // MOD_ALT | MOD_CONTROL | MOD_SHIFT | MOD_WIN
    RegisterHotKey(NULL, 1, MOD_WIN | MOD_ALT, &#39;S&#39;); // Suspend
    RegisterHotKey(NULL, 2, MOD_WIN | MOD_ALT, &#39;R&#39;); // Resume
    RegisterHotKey(NULL, 3, MOD_WIN | MOD_ALT, &#39;K&#39;); // Kill
    MSG msg = {0};
    while (GetMessage(&amp;msg, NULL, 0, 0))
    {
        if (msg.message == WM_HOTKEY)
        {
            switch (msg.wParam)
            {
                case 1:
                    NtSuspendProcess(handle);
                    Sleep(350); // Wait until the key pops up and the desktop is loaded
                    minimizeForegroundWindow();
                    NtResumeProcess(handle); // Temporarily recover the process
                    Sleep(100);
                    NtSuspendProcess(handle);
                    printLogHead();
                    printf(&quot;Process %d has been suspended\n&quot;, pid);
                    break;
                case 2:
                    for(int i = 0; i &lt; 9; i++)
                    {
                        NtResumeProcess(handle);
                    }
                    printLogHead();
                    printf(&quot;Process %d has been resumed\n&quot;, pid);
                    break;
                case 3:
                    NtTerminateProcess(handle);
                    printLogHead();
                    printf(&quot;Process %d has been killed\n&quot;, pid);
                    printLogHead();
                    printf(&quot;Press any key to exit\n&quot;);
                    getchar();
                    return 0;
                    break;
            }
        }
    }
    getchar();
    return 0;
}

void printLogHead()
{
    SYSTEMTIME time; 
    GetLocalTime(&amp;time);
    printf(&quot;[%02d:%02d:%02d] &quot;, time.wHour, time.wMinute, time.wSecond);
    return;
}

void minimizeForegroundWindow()
{
    HWND hwnd = GetForegroundWindow();
    ShowWindow(hwnd, SW_MINIMIZE);
    return;
}

int getPid(char* processName)
{
    HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    int pid = 0;
    do
    {
        if (!lstrcmpi(processName, pe32.szExeFile))
        {
            pid = pe32.th32ProcessID;
            break;
        }
    }
    while (Process32Next(handle, &amp;pe32));
    CloseHandle(handle);
    return pid;
}</code></pre><h3 id=introduction>Introduction</h3><ul><li><p>用法参照控制台输出的使用说明。</p></li><li><p>兼容XP~10，理论上适配任意版本客户端。</p></li><li><p>别高兴得太早，仅支持无KeyboardHook的客户端版本。</p></li><li><p>如果你实在懒得Build，那么我只能说——</p></li></ul><p><a href=https://pan.baidu.com/s/1CrVYB_ysCSCUwATTCe8zTQ>https://pan.baidu.com/s/1CrVYB_ysCSCUwATTCe8zTQ</a></p><p>Password:<code>if7f</code></p><h3 id=update-history>Update History</h3><h4 id=20190404>20190404</h4><ul><li>注册快捷键，赋予你在屏幕广播开始后跳出的能力。</li></ul><h4 id=20181109>20181109</h4><ul><li>改用挂起进程的方式规避教师端管控。教师端不会提示掉线，屏幕监控会定格。</li></ul><h4 id=20180907>20180907</h4><ul><li>首个版本。</li></ul></article></main><header class=in id=extra></header></body></html>